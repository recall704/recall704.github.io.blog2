<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />

  
  <title>recall&#39;s blog</title>

  
  





  
  <meta name="author" content="recall704" />
  <meta name="description" content="" />

  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@gohugoio" />
  <meta name="twitter:title" content="recall&#39;s blog" />
  <meta name="twitter:description" content="" />
  <meta name="twitter:image" content="http://www.recall704.com/img/avatar.jpg" />

  
  <meta property="og:type" content="website" />
  <meta property="og:title" content="recall&#39;s blog" />
  <meta property="og:description" content="" />
  <meta property="og:url" content="http://www.recall704.com/" />
  <meta property="og:image" content="http://www.recall704.com/img/avatar.jpg" />




<meta name="generator" content="Hugo 0.41" />


<link rel="canonical" href="http://www.recall704.com/" />
<link rel="alternate" type="application/rss" href="http://www.recall704.com/index.xml" title="Recall's blog" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />







<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Recall&#39;s blog" />
<meta name="msapplication-tooltip" content="Recall&#39;s blog" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="http://www.recall704.com/img/bio.jpg" />
<link rel="icon" type="image/png" sizes="16x16" href="http://www.recall704.com/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="http://www.recall704.com/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="http://www.recall704.com/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="http://www.recall704.com/img/touch-icon-apple.png" />
<link rel="mask-icon" href="http://www.recall704.com/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="http://www.recall704.com/css/bundle.6271cf88a8.css" />


  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.8/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.4/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="http://www.recall704.com/img/bio.jpg" alt="Avatar">
  
  <h1 class="title">Recall&#39;s blog</h1>
  
  <p class="subtitle">学无先后，达者为师</p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
            
              is-active
            
            
            ">
            <a href="http://www.recall704.com/">Home</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="http://www.recall704.com/tags/">Tags</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="http://www.recall704.com/categories/">Categories</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="http://www.recall704.com/series/">series</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="http://www.recall704.com/links/">友情链接</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="http://www.recall704.com/about/">初恋</a>
          </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      
      <li class="social-item">
        <a href="mailto:tk657309822@gmail.com" title="Email"><span class="icon icon-email"></span></a>
      </li>

      
      <li class="social-item">
        <a href="//github.com/recall704" title="GitHub"><span class="icon icon-github"></span></a>
      </li>

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="http://www.recall704.com/img/vx.png" title="Wechat"><span class="icon icon-wechat"></span></a>
      </li>

      

      

      

      

      <li class="social-item">
        <a rel="alternate" type="application/rss+xml" href="http://www.recall704.com/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
</header>

  <section class="main post-list">
    <header class="list-header offscreen">
      <h2 class="list-label">All Posts</h2>
    </header>
    
    
      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s/scheduler/pod-match-node-selector/" class="post-link">k8s 调度算法分析之 MatchNodeSelector（四）</a></h3>
    <p class="post-meta">@recall704 · Sep 24, 2018 · 2 min read</p>
  </header>
  
  <p class="post-summary">一、概述 之前的文章有简要分析 k8s 的调度过程，主要就是
1. 节点筛选（选取可用的节点）
2. 节点排序（选取最优节点）
今天我们来详细分析其中的一个筛选算法 MatchNodeSelector
二、代码分析 MatchNodeSelector 对应的函数为 PodMatchNodeSelector
// PodMatchNodeSelector checks if a pod node selector matches the node label. func PodMatchNodeSelector(pod *v1.Pod, meta algorithm.PredicateMetadata, nodeInfo *schedulercache.NodeInfo) (bool, []algorithm.PredicateFailureReason, error) { node := nodeInfo.Node() if node == nil { return false, nil, fmt.Errorf(&#34;node not found&#34;) } if podMatchesNodeLabels(pod, node) { return true, nil, nil } return false, []algorithm.PredicateFailureReason{ErrNodeSelectorNotMatch}, nil } 这个函数看起来超级简单，但内部其实分为两个部分的。
1. selector</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s/scheduler/pod-match-node-selector/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s/scheduler/pod-fits-host-ports/" class="post-link">k8s 调度算法分析之 PodFitsHostPorts（三）</a></h3>
    <p class="post-meta">@recall704 · Sep 24, 2018 · 2 min read</p>
  </header>
  
  <p class="post-summary">一、概述 之前的文章有简要分析 k8s 的调度过程，主要就是
1. 节点筛选（选取可用的节点）
2. 节点排序（选取最优节点）
今天我们来详细分析其中的一个筛选算法 PodFitsHostPorts
二、代码分析 // PodFitsHostPorts checks if a node has free ports for the requested pod ports. func PodFitsHostPorts(pod *v1.Pod, meta algorithm.PredicateMetadata, nodeInfo *schedulercache.NodeInfo) (bool, []algorithm.PredicateFailureReason, error) { var wantPorts map[string]bool if predicateMeta, ok := meta.(*predicateMetadata); ok { wantPorts = predicateMeta.podPorts } else { // We couldn&#39;t parse metadata - fallback to computing it. 	wantPorts = schedutil.GetUsedPorts(pod) } if len(wantPorts) == 0 { return true, nil, nil } existingPorts := nodeInfo.</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s/scheduler/pod-fits-host-ports/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s/scheduler/pod-fits-resource/" class="post-link">k8s 调度算法分析之 PodFitsResources（二）</a></h3>
    <p class="post-meta">@recall704 · Sep 22, 2018 · 3 min read</p>
  </header>
  
  <p class="post-summary">一、概述 之前的文章有简要分析 k8s 的调度过程，主要就是
1. 节点筛选（选取可用的节点）
2. 节点排序（选取最优节点）
今天我们来详细分析其中的一个筛选算法 PodFitsResources
二、代码分析 只贴代码是没有任何意义的，我们来逐行分析
// PodFitsResources checks if a node has sufficient resources, such as cpu, memory, gpu, opaque int resources etc to run a pod. // First return value indicates whether a node has sufficient resources to run a pod while the second return value indicates the // predicate failure reasons if the node has insufficient resources to run the pod.</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s/scheduler/pod-fits-resource/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/volume-of-k8s/" class="post-link">k8s 学习笔记之存储</a></h3>
    <p class="post-meta">@recall704 · Sep 4, 2018 · 6 min read</p>
  </header>
  
  <p class="post-summary">一、几个存储的概念 1. pv A PersistentVolume is a piece of storage in the cluster that has been provisioned by an administrator.
2. pvc A PersistentVolumeClaims is a request for storage by a user.
3. storageclass A storageclass provides a way for administrator to describe the classes of storage they offer.
pv 支持两种方式的 provision，静态和动态
1. static A cluster administrator create a number of PVs. 管理员先创建一堆 PVs，然后提供给 PVC 绑定
2. Dynamic Base StorageClasses, when none of the static PVs the administrator created matches a user’s PersistentVolumeClaim, the cluster may try to dynamically provision a volume specially for the PVC.</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/volume-of-k8s/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s/scheduler/k8s-scheduler/" class="post-link">k8s pod 调度分析（零）</a></h3>
    <p class="post-meta">@recall704 · Aug 14, 2018 · 2 min read</p>
  </header>
  
  <p class="post-summary">一、k8s 基础架构 在分析 k8s pod 调度之前，我们先来回顾一下 k8s 的架构
二、k8s pod 调度相关的参数 当用户通过 kubectl 或者 api 创建了一个 deployment 或者 其它 workload 的时候， k8s 会创建对应的 pod 信息，pod 信息最终会传递给 kubelet，实例化成具体的 docker 容器， 那么 k8s 是根据什么条件，怎么把 pod “安排”到 node 上去的呢？ 有哪些因数会影响 pod 的调度呢？
我找了一下 pod 的参数，大概会有以下几个参数影响 pod 的调度
1. NodeName 2. NodeSelector 3. Affinity 4. Tolerations 5. PriorityClassName 6. Priority 1. nodeName 一旦你在 pod 里指定了 nodeName ,那么 pod 一定会调度到该节点上, 其实 pod 已经跳过了调度过程了
2. Priority pod 是可以有优先级的，这个优先级是相对于其它 pod 的，也就是说，如果 pod 的优先级高于其它 pod，这个 pod 会被优先调度。</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s/scheduler/k8s-scheduler/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s-nodeport-range/" class="post-link">k8s nodeport 端口范围</a></h3>
    <p class="post-meta">@recall704 · Aug 14, 2018 · 1 min read</p>
  </header>
  
  <p class="post-summary">k8s 的 nodeport 默认范围是 30000-32767，那这个端口范围到底是半开半闭区间，还是开区间，还是闭区间呢？ 而且能不能是不连续的呢？ 能不能像（80，443， 30000-32767）这样呢？
在 k8s 源码中搜索 32767，在
gopath/src/k8s.io/kubernetes/cmd/kube-apiserver/app/options/options.go 存在代码
fs.Var(&amp;s.ServiceNodePortRange, &#34;service-node-port-range&#34;, &#34;&#34;&#43; &#34;A port range to reserve for services with NodePort visibility. &#34;&#43; &#34;Example: &#39;30000-32767&#39;. Inclusive at both ends of the range.&#34;) 其实上面注释已经说了是闭区间了，但是我还是要看看
搜索 ServiceNodePortRange 在
gopath/src/k8s.io/kubernetes/cmd/kube-apiserver/app/options/options.go 中存在
ServiceNodePortRange: kubeoptions.DefaultServiceNodePortRange, 跟踪 DefaultServiceNodePortRange 找到
var DefaultServiceNodePortRange = utilnet.PortRange{Base: 30000, Size: 2768} 跟踪 PortRange 找到
type PortRange struct { Base int Size int } // Contains tests whether a given port falls within the PortRange.</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s-nodeport-range/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s-replicaset/" class="post-link">k8s 源码分析: ReplicaSet 控制器</a></h3>
    <p class="post-meta">@recall704 · Apr 26, 2018 · 2 min read</p>
  </header>
  
  <p class="post-summary">0x01 RS 控制器 func (rsc *ReplicaSetController) manageReplicas(filteredPods []*v1.Pod, rs *extensions.ReplicaSet) error { // 当前 pod 数量，期望 pod 数量 	diff := len(filteredPods) - int(*(rs.Spec.Replicas)) rsKey, err := controller.KeyFunc(rs) if err != nil { utilruntime.HandleError(fmt.Errorf(&#34;Couldn&#39;t get key for %v %#v: %v&#34;, rsc.Kind, rs, err)) return nil } if diff &lt; 0 { // 当前 pod 数量 &lt; 期望 pod 数量 	// 需要增加 pod 	diff *= -1 if diff &gt; rsc.</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s-replicaset/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s-authentication-with-basic/" class="post-link">创建 client （三）： HTTP Basic Auth 访问 k8s API Server</a></h3>
    <p class="post-meta">@recall704 · Apr 15, 2018 · 2 min read</p>
  </header>
  
  <p class="post-summary">0x01 结构体 AuthInfo 如果你留意过上一篇文章，你会发现一个结构体
AuthInfo: clientcmdapi.AuthInfo{ ClientCertificate: &#34;client.crt&#34;, ClientKey: &#34;client.key&#34;, },  其对应代码在 client-go 下的 k8s.io/client-go/tools/clientcmd/api 中
type AuthInfo struct { // LocationOfOrigin indicates where this object came from. It is used for round tripping config post-merge, but never serialized. 	LocationOfOrigin string // ClientCertificate is the path to a client cert file for TLS. 	// &#43;optional 	ClientCertificate string `json:&#34;client-certificate,omitempty&#34;` // ClientCertificateData contains PEM-encoded data from a client cert file for TLS.</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s-authentication-with-basic/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s-authentication-with-ca/" class="post-link">创建 client （二）： 通过配置文件方式访问 k8s API</a></h3>
    <p class="post-meta">@recall704 · Apr 15, 2018 · 2 min read</p>
  </header>
  
  <p class="post-summary">0x01 概述 前面我讲过集群内通过 ServiceAccount 生成 token 的方式访问 k8s API Server， 那么如果我们要访问 k8s api 的应用不是跑在 k8s 之内，而是在 k8s 集群之外运行呢？
这个时候，我们还有两种认证方式
 ca 证书认证
 basic 认证  0x02 kubectl 是如何访问 k8s 的？ k8s 部署的时候，我们会给 kubectl 配置证书，context 等信息，生成一个 $HOME/.kube/config 这样的文件，文件内容如下 apiVersion: v1 clusters: - cluster: certificate-authority-data: ... server: https://192.168.1.200:6443 name: kube_cluster contexts: - context: cluster: kube_cluster namespace: kube-system user: kubectl name: kubectl@kube_cluster current-context: kubectl@kube_cluster kind: Config preferences: {} users: - name: kubectl user: as-user-extra: {} client-certificate-data: .</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s-authentication-with-ca/">Read More →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="http://www.recall704.com/cloud/k8s-operator/" class="post-link">k8s operator 简介</a></h3>
    <p class="post-meta">@recall704 · Apr 13, 2018 · 1 min read</p>
  </header>
  
  <p class="post-summary">0x1 Operator 介绍 Operator 是 CoreOS 公司提出的一个概念，用来创建、配置、管理复杂应用，由两部分构成：
 1. Resource
 1.1 自定义资源
 1.2 为用户提供一种简单的方式描述对服务的期望
  2. Controller
 2.1 创建 Resource
 2.2 监听 Resource 的变更，用来实现用户对服务的期望
   0x2 Operator 工作流程  1. 注册自定义资源 CustomResource
 2. 监听(watch)自定义资源
 3. 用户对自定义进行 CREATE/UPDATE/DELETE 操作
 4. 当监听到资源变化之后，调用对应的 handler 进行处理
  如果你了解 k8s 的内部原理，你会发现其实 k8s 本身就是这样做的，
比如 deployment ，只是 deployment 资源是内置资源，
不用向 APIServer 进行注册了而已，deployment controller 会对资源进行监控和处理。</p>
  <footer class="post-footer">
    <a class="read-more" href="http://www.recall704.com/cloud/k8s-operator/">Read More →</a>
  </footer>
</article>

      
    
    
      <footer class="list-footer">
        <nav class="pagination">
          <h3 class="offscreen">Pagination</h3>
          
          
            <a class="pagination-next" href="http://www.recall704.com/page/2/">Older Posts →</a>
          
        </nav>
      </footer>
    
  </section>
  <footer class="site-footer">
  <p>© 2017-2018 Recall&#39;s blog</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script src="http://www.recall704.com/js/bundle.fb61ec41f8.js"></script>




  </body>
</html>
